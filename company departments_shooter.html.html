<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éš¨èº«ç‰©å“å¤§å°„æ“Š</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            overscroll-behavior: none;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .game-canvas {
            background: linear-gradient(to bottom, #1a202c, #2d3748);
            box-shadow: inset 0 0 20px #000;
        }
        /* Custom Scrollbar for the word panel if needed */
        .word-grid::-webkit-scrollbar {
            width: 6px;
        }
        .word-grid::-webkit-scrollbar-thumb {
            background-color: #4a5568;
            border-radius: 4px;
        }
        .btn-press {
            transition: transform 0.1s;
        }
        .btn-press:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body class="bg-gray-900 h-screen w-screen flex flex-col overflow-hidden text-white select-none">

    <!-- Game Header -->
    <div class="flex justify-between items-center px-4 py-2 bg-gray-800 border-b border-gray-700 h-14 shrink-0">
        <div>
            <h1 class="text-lg font-bold text-yellow-400">ğŸ’ éš¨èº«ç‰©å“è¡›å£«</h1>
        </div>
        <div class="flex gap-4">
            <div class="text-right">
                <span class="text-xs text-gray-400">é€²åº¦</span>
                <div id="progressDisplay" class="text-xl font-mono font-bold text-blue-400">0/0</div>
            </div>
            <div class="text-right">
                <span class="text-xs text-gray-400">åˆ†æ•¸</span>
                <div id="scoreDisplay" class="text-xl font-mono font-bold text-green-400">0</div>
            </div>
            <div class="text-right">
                <span class="text-xs text-gray-400">ç”Ÿå‘½</span>
                <div id="livesDisplay" class="text-xl font-mono font-bold text-red-400">â¤â¤â¤</div>
            </div>
        </div>
    </div>

    <!-- Canvas Area -->
    <div class="flex-grow relative flex justify-center items-center bg-gray-900 w-full overflow-hidden" id="canvasContainer">
        <canvas id="gameCanvas" class="game-canvas w-full h-full"></canvas>
        
        <!-- Start Screen Overlay -->
        <div id="startScreen" class="absolute inset-0 bg-black/80 flex flex-col justify-center items-center z-10">
            <h2 class="text-4xl font-bold mb-4 text-white">æº–å‚™å¥½äº†å—ï¼Ÿ</h2>
            <p class="text-gray-300 mb-8 text-center px-4">
                å·¦å³æ»‘å‹•æ§åˆ¶æˆ°è»Š<br>
                é»æ“Šä¸‹æ–¹å–®å­—ç™¼å°„å°æ‡‰å­å½ˆ<br>
                <span class="text-yellow-400 font-bold">å°å¿ƒå¾å¤©è€Œé™çš„é›·é›»ï¼</span><br>
                <span class="text-blue-300" id="missionText">æ”¶é›†æ»¿æ‰€æœ‰ç‰©å“å³å¯éé—œï¼</span>
            </p>
            <button id="startBtn" class="px-8 py-3 bg-blue-600 hover:bg-blue-500 rounded-lg text-xl font-bold shadow-lg transform transition hover:scale-105">é–‹å§‹éŠæˆ²</button>
        </div>

        <!-- Game Over Overlay -->
        <div id="gameOverScreen" class="hidden absolute inset-0 bg-red-900/95 flex flex-col justify-center items-center z-20">
            <h2 class="text-5xl font-bold mb-2 text-white">éŠæˆ²çµæŸ</h2>
            <p class="text-xl mb-6 text-gray-200">é‚„å·®ä¸€é»é»ï¼å°å¿ƒé›·é›»ï¼</p>
            <p class="text-2xl mb-6">æœ€çµ‚åˆ†æ•¸: <span id="finalScore" class="font-mono text-yellow-300">0</span></p>
            <button id="restartBtn" class="px-8 py-3 bg-white text-red-900 rounded-lg text-xl font-bold shadow-lg transform transition hover:scale-105">å†ç©ä¸€æ¬¡</button>
        </div>

        <!-- Win Screen Overlay -->
        <div id="winScreen" class="hidden absolute inset-0 bg-yellow-600/95 flex flex-col justify-center items-center z-20">
            <h2 class="text-5xl font-bold mb-2 text-white">ğŸ‰ é—–é—œæˆåŠŸï¼</h2>
            <p class="text-xl mb-6 text-white">å¤ªæ£’äº†ï¼æ‰€æœ‰çš„ç‰©å“éƒ½æ”¶é›†é½Šå…¨äº†ï¼</p>
            <p class="text-2xl mb-6 text-white">æœ€çµ‚åˆ†æ•¸: <span id="winScore" class="font-mono text-yellow-100 font-bold">0</span></p>
            <button id="winRestartBtn" class="px-8 py-3 bg-white text-yellow-700 rounded-lg text-xl font-bold shadow-lg transform transition hover:scale-105">å†æŒ‘æˆ°ä¸€æ¬¡</button>
        </div>
    </div>

    <!-- Word Control Panel (The "Ammo") -->
    <div class="h-1/3 bg-gray-800 border-t border-gray-600 p-2 shrink-0 flex flex-col">
        <div class="text-center text-xs text-gray-400 mb-1">é»æ“Šå–®å­—ç™¼å°„å­å½ˆ (Click Word to Fire)</div>
        <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-2 h-full overflow-y-auto word-grid pb-2" id="wordButtons">
            <!-- Buttons generated by JS -->
        </div>
    </div>

    <script>
        // --- éŠæˆ²è³‡æ–™ (æ›´æ–°å¾Œçš„å–®å­—åˆ—è¡¨) ---
        const VOCABULARY = [
            { word: "bag", img: "bag.png", emoji: "ğŸ‘œ", label: "åŒ…åŒ…" },
            { word: "bandage", img: "bandage.jpg", emoji: "ğŸ©¹", label: "ç¹ƒå¸¶" },
            { word: "book", img: "book.png", emoji: "ğŸ“–", label: "æ›¸" },
            { word: "comb", img: "comb.png", emoji: "ğŸª®", label: "æ¢³å­" },
            { word: "earphones", img: "earphones.png", emoji: "ğŸ§", label: "è€³æ©Ÿ" },
            { word: "first-aid kit", img: "first-aid kit.jpg", emoji: "â›‘ï¸", label: "æ€¥æ•‘ç®±" },
            { word: "hair band", img: "hair band.jpg", emoji: "ğŸ€", label: "é«®å¸¶" },
            { word: "laptop", img: "laptop.jpg", emoji: "ğŸ’»", label: "ç­†è¨˜å‹é›»è…¦" },
            { word: "mint", img: "mint.png", emoji: "ğŸ¬", label: "è–„è·ç³–" },
            { word: "mirror", img: "mirror.png", emoji: "ğŸª", label: "é¡å­" },
            { word: "notebook", img: "notebook.png", emoji: "ğŸ““", label: "ç­†è¨˜æœ¬" },
            { word: "pen", img: "pen.png", emoji: "ğŸ–Šï¸", label: "ç­†" },
            { word: "phone charger", img: "phone charger.png", emoji: "ğŸ”Œ", label: "å……é›»å™¨" },
            { word: "swing kit", img: "swing kit.jpg", emoji: "ğŸ§µ", label: "é‡ç·šåŒ…" },
            { word: "smartphone", img: "smartphone.png", emoji: "ğŸ“±", label: "æ™ºæ…§å‹æ‰‹æ©Ÿ" },
            { word: "sunglasses", img: "sunglasses.png", emoji: "ğŸ•¶ï¸", label: "å¤ªé™½çœ¼é¡" },
            { word: "tablet", img: "tablet.jpg", emoji: "ğŸ“±", label: "å¹³æ¿é›»è…¦" },
            { word: "tissue", img: "tissue.png", emoji: "ğŸ§»", label: "é¢ç´™" },
            { word: "umbrella", img: "umbrella.png", emoji: "â˜‚ï¸", label: "é›¨å‚˜" },
            { word: "wallet", img: "wallet.png", emoji: "ğŸ‘›", label: "çš®å¤¾" }
        ];

        // --- ç³»çµ±è®Šæ•¸ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvasContainer');
        const scoreEl = document.getElementById('scoreDisplay');
        const livesEl = document.getElementById('livesDisplay');
        const progressEl = document.getElementById('progressDisplay');
        const finalScoreEl = document.getElementById('finalScore');
        const winScoreEl = document.getElementById('winScore');
        const wordGrid = document.getElementById('wordButtons');
        
        let gameState = 'START'; // START, PLAYING, GAMEOVER, WIN
        let score = 0;
        let lives = 3;
        let lastTime = 0;
        let spawnTimer = 0;
        let spawnInterval = 2000;
        let difficultyMultiplier = 1;
        
        // è¿½è¹¤å·²æ”¶é›†çš„å–®å­—
        let clearedWords = new Set();

        // --- éŠæˆ²ç‰©ä»¶ ---
        const tank = {
            x: 0,
            y: 0,
            width: 50,
            height: 40,
            color: '#3b82f6',
            targetX: 0
        };

        let enemies = [];
        let bullets = [];
        let particles = [];
        let lightnings = []; // æ–°å¢ï¼šé›·é›»é™£åˆ—
        
        // --- åˆå§‹åŒ–åœ–ç‰‡è¼‰å…¥ ---
        VOCABULARY.forEach(item => {
            const img = new Image();
            img.src = item.img;
            img.onload = () => { item.loadedImg = img; };
            img.onerror = () => { item.loadedImg = null; };
        });

        // --- åˆå§‹åŒ– UI ---
        function initUI() {
            // æ›´æ–°ä»»å‹™èªªæ˜æ–‡å­—
            document.getElementById('missionText').innerText = `æ”¶é›†æ»¿ ${VOCABULARY.length} å€‹ç‰©å“å³å¯éé—œï¼`;

            wordGrid.innerHTML = '';
            
            VOCABULARY.forEach(item => {
                const btn = document.createElement('button');
                btn.id = `btn-${item.word.replace(/\s+/g, '-')}`; 
                btn.className = 'btn-press bg-gray-700 hover:bg-gray-600 text-white font-semibold py-1 px-1 rounded border border-gray-500 text-xs flex flex-col items-center justify-center h-full transition-colors duration-300 min-h-[50px]';
                
                // --- ä¿®æ”¹è™•ï¼šç§»é™¤ item.label (ä¸­æ–‡é¡¯ç¤º) ---
                btn.innerHTML = `<span class="text-yellow-300 leading-tight text-center break-words w-full text-sm font-bold">${item.word}</span>`;
                
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    fireBullet(item.word);
                    btn.classList.add('bg-blue-600', 'border-blue-400');
                    setTimeout(() => btn.classList.remove('bg-blue-600', 'border-blue-400'), 150);
                });

                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    btn.click();
                }, {passive: false});

                wordGrid.appendChild(btn);
            });
            
            updateProgressUI();
        }

        function resize() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            tank.y = canvas.height - 60;
            tank.x = canvas.width / 2;
            tank.targetX = canvas.width / 2;
        }
        window.addEventListener('resize', resize);

        // --- éŠæˆ²æ ¸å¿ƒé‚è¼¯ ---

        function startGame() {
            gameState = 'PLAYING';
            score = 0;
            lives = 3;
            difficultyMultiplier = 1;
            spawnInterval = 2500;
            enemies = [];
            bullets = [];
            particles = [];
            lightnings = []; // é‡ç½®é›·é›»
            clearedWords.clear();
            
            updateScoreUI();
            updateProgressUI();
            
            document.querySelectorAll('#wordButtons button').forEach(btn => {
                btn.classList.remove('opacity-50', 'bg-green-800');
                btn.classList.add('bg-gray-700');
            });

            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('winScreen').classList.add('hidden');
            
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            finalScoreEl.innerText = score;
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function gameWin() {
            gameState = 'WIN';
            winScoreEl.innerText = score;
            document.getElementById('winScreen').classList.remove('hidden');
            for(let i=0; i<10; i++) {
                setTimeout(() => {
                    createExplosion(canvas.width/2 + (Math.random()-0.5)*300, canvas.height/2 + (Math.random()-0.5)*300, ['#FFD700', '#FFF', '#FFA500'][Math.floor(Math.random()*3)]);
                }, i * 200);
            }
        }

        function fireBullet(word) {
            if (gameState !== 'PLAYING') return;
            bullets.push({
                x: tank.x,
                y: tank.y - 20,
                word: word,
                width: 120,
                speed: 10,
                active: true
            });
        }

        function spawnEnemy() {
            const uncollected = VOCABULARY.filter(v => !clearedWords.has(v.word));
            const pool = uncollected.length > 0 ? uncollected : VOCABULARY;
            const item = pool[Math.floor(Math.random() * pool.length)];
            const size = 80;
            const x = Math.random() * (canvas.width - size - 20) + size/2 + 10; 
            
            enemies.push({
                x: x,
                y: -80,
                size: size,
                word: item.word,
                emoji: item.emoji,
                img: item.loadedImg,
                speed: 1.0 * difficultyMultiplier, 
                rotation: 0 
            });
        }

        // --- æ–°å¢ï¼šç”Ÿæˆé›·é›» ---
        function spawnLightning() {
            const x = Math.random() * (canvas.width - 20) + 10;
            lightnings.push({
                x: x,
                y: -60,
                width: 30, // åˆ¤å®šå¯¬åº¦
                height: 60, // åˆ¤å®šé«˜åº¦
                speed: 6 * difficultyMultiplier, // é›·é›»é€Ÿåº¦è¼ƒå¿«
                active: true
            });
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0,
                    color: color,
                    size: Math.random() * 5 + 2
                });
            }
        }

        function update(dt) {
            if (gameState !== 'PLAYING') {
                particles.forEach(p => {
                    p.x += p.vx; p.y += p.vy; p.life -= 0.05;
                });
                particles = particles.filter(p => p.life > 0);
                return;
            }

            difficultyMultiplier = 1 + (score / 1000); 
            if (spawnInterval > 800) spawnInterval = 2500 - (score * 5);

            tank.x += (tank.targetX - tank.x) * 0.2;
            if (tank.x < tank.width/2) tank.x = tank.width/2;
            if (tank.x > canvas.width - tank.width/2) tank.x = canvas.width - tank.width/2;

            spawnTimer += dt;
            if (spawnTimer > spawnInterval) {
                spawnEnemy();
                spawnTimer = 0;
            }

            // --- æ–°å¢ï¼šéš¨æ©Ÿç”Ÿæˆé›·é›» ---
            if (Math.random() < 0.005 + (score * 0.00001)) { // éš¨æ©Ÿç”Ÿæˆæ©Ÿç‡ï¼Œéš¨åˆ†æ•¸å¾®å¹…å¢åŠ 
                spawnLightning();
            }

            // æ›´æ–°é›·é›»
            lightnings.forEach(l => {
                l.y += l.speed;
                // é›·é›»ç¢°æ’æª¢æ¸¬
                if (Math.abs(l.x - tank.x) < (l.width + tank.width)/2 && Math.abs(l.y - tank.y) < (l.height + tank.height)/2) {
                    createExplosion(tank.x, tank.y, '#ffff00'); // é»ƒè‰²çˆ†ç‚¸
                    lives--;
                    updateScoreUI();
                    l.active = false;
                    if (lives <= 0) gameOver();
                }
                if (l.y > canvas.height) l.active = false;
            });
            lightnings = lightnings.filter(l => l.active);


            bullets.forEach(b => {
                b.y -= b.speed;
                if (b.y < -50) b.active = false;
            });

            enemies.forEach(e => {
                e.y += e.speed;

                const dx = e.x - tank.x;
                const dy = e.y - tank.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < (e.size/2 + tank.width/2 - 10)) {
                    createExplosion(tank.x, tank.y, '#ef4444');
                    lives--;
                    updateScoreUI();
                    e.active = false;
                    if (lives <= 0) gameOver();
                }

                bullets.forEach(b => {
                    if (!b.active) return;
                    
                    if (Math.abs(b.x - e.x) < (e.size + 20) && Math.abs(b.y - e.y) < e.size) {
                        if (b.word === e.word) {
                            score += 10;
                            
                            if (!clearedWords.has(e.word)) {
                                clearedWords.add(e.word);
                                const btnId = `btn-${e.word.replace(/\s+/g, '-')}`;
                                const btn = document.getElementById(btnId);
                                if(btn) {
                                    btn.classList.remove('bg-gray-700');
                                    btn.classList.add('bg-green-800');
                                }
                            }

                            updateScoreUI();
                            updateProgressUI();
                            createExplosion(e.x, e.y, '#fbbf24');
                            
                            e.active = false;
                            b.active = false;

                            if (clearedWords.size >= VOCABULARY.length) {
                                setTimeout(gameWin, 500); 
                            }

                        } else {
                            b.active = false;
                        }
                    }
                });

                if (e.y > canvas.height + 50) {
                    e.active = false;
                }
            });

            bullets = bullets.filter(b => b.active);
            enemies = enemies.filter(e => e.active !== false);

            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
            });
            particles = particles.filter(p => p.life > 0);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç¶²æ ¼èƒŒæ™¯
            ctx.strokeStyle = '#2d3748';
            ctx.lineWidth = 1;
            for(let i=0; i<canvas.width; i+=50) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
            }

            // æˆ°è»Š
            ctx.save();
            ctx.translate(tank.x, tank.y);
            ctx.fillStyle = tank.color;
            ctx.beginPath();
            ctx.moveTo(-20, 20); ctx.lineTo(20, 20); ctx.lineTo(15, -10); ctx.lineTo(-15, -10);
            ctx.fill();
            ctx.fillStyle = '#60a5fa'; ctx.fillRect(-5, -30, 10, 25);
            ctx.fillStyle = '#1e3a8a'; ctx.fillRect(-25, 10, 10, 15); ctx.fillRect(15, 10, 10, 15);
            ctx.restore();

            // å­å½ˆ
            ctx.font = 'bold 22px Arial'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            bullets.forEach(b => {
                ctx.fillStyle = '#fcd34d';
                ctx.fillText(b.word, b.x, b.y);
                ctx.shadowColor = '#f59e0b'; ctx.shadowBlur = 10;
                ctx.fillRect(b.x - 2, b.y + 12, 4, 12); ctx.shadowBlur = 0;
            });

            // --- æ–°å¢ï¼šç¹ªè£½é›·é›» ---
            lightnings.forEach(l => {
                ctx.save();
                ctx.translate(l.x, l.y);
                ctx.beginPath();
                ctx.strokeStyle = '#fde047'; // é»ƒè‰²
                ctx.lineWidth = 4;
                ctx.shadowColor = '#fef08a';
                ctx.shadowBlur = 10;
                // ç•«ä¸€å€‹ç°¡å–®çš„é–ƒé›»å½¢ç‹€ (Zå­—å½¢)
                ctx.moveTo(0, -20);
                ctx.lineTo(-10, 0);
                ctx.lineTo(10, 0);
                ctx.lineTo(-5, 20);
                ctx.stroke();
                ctx.restore();
            });

            // æ•µäºº
            enemies.forEach(e => {
                ctx.save();
                ctx.translate(e.x, e.y);
                
                if (clearedWords.has(e.word)) {
                    ctx.strokeStyle = '#fbbf24'; // Gold
                    ctx.shadowColor = '#fbbf24';
                    ctx.shadowBlur = 15;
                } else {
                    ctx.strokeStyle = '#fff';
                    ctx.shadowBlur = 0;
                }
                
                ctx.lineWidth = 3; 
                ctx.strokeRect(-e.size/2, -e.size/2, e.size, e.size);
                
                if (e.img) {
                    ctx.drawImage(e.img, -e.size/2, -e.size/2, e.size, e.size);
                } else {
                    ctx.fillStyle = '#000000aa';
                    ctx.fillRect(-e.size/2, -e.size/2, e.size, e.size);
                    ctx.font = '45px Arial';
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(e.emoji, 0, 0);
                }
                ctx.restore();
            });

            // ç²’å­
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size || 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });
        }

        function gameLoop(timestamp) {
            const dt = timestamp - lastTime;
            lastTime = timestamp;
            update(dt);
            draw();
            if (gameState === 'PLAYING' || particles.length > 0) {
                requestAnimationFrame(gameLoop);
            }
        }

        function updateScoreUI() {
            scoreEl.innerText = score;
            let livesStr = '';
            for(let i=0; i<lives; i++) livesStr += 'â¤';
            livesEl.innerText = livesStr;
        }

        function updateProgressUI() {
            progressEl.innerText = `${clearedWords.size}/${VOCABULARY.length}`;
        }

        // --- è¼¸å…¥æ§åˆ¶ ---
        function handleInput(clientX) {
            const rect = canvas.getBoundingClientRect();
            let x = clientX - rect.left;
            tank.targetX = x;
        }

        canvas.addEventListener('mousemove', e => handleInput(e.clientX));
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            handleInput(e.touches[0].clientX);
        }, {passive: false});

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        document.getElementById('winRestartBtn').addEventListener('click', startGame);

        // --- å•Ÿå‹• ---
        initUI();
        resize();
        
        ctx.fillStyle = '#1a202c';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

    </script>
</body>
</html>